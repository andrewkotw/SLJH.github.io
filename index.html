<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ’åºæ¼”ç®—æ³•äº’å‹•å¯¦é©—å®¤</title>
    <!-- å¼•å…¥ Tailwind CSS é€²è¡Œæ¨£å¼æ¸²æŸ“ -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- å¼•å…¥ React æ ¸å¿ƒåº« -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- å¼•å…¥ Babel ç”¨æ–¼è§£æ JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- å¼•å…¥ Lucide åœ–ç¤ºåº« -->
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-8px); }
            75% { transform: translateX(8px); }
        }
        .animate-shake { animation: shake 0.2s ease-in-out 0s 2; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        /**
         * ä¿®æ­£å¾Œçš„ Icon çµ„ä»¶
         * ä½¿ç”¨ lucide.createIcons ç›´æ¥è™•ç† DOM æ³¨å…¥ï¼Œé¿å… API æ–¹æ³•ç¼ºå¤±å•é¡Œ
         */
        const Icon = ({ name, className, size = 24 }) => {
            const iconRef = useRef(null);
            
            useEffect(() => {
                if (iconRef.current && window.lucide) {
                    // æ¸…ç©ºå…§å®¹
                    iconRef.current.innerHTML = '';
                    // å»ºç«‹ä¸€å€‹è‡¨æ™‚çš„ i æ¨™ç±¤ä¾› Lucide æ¸²æŸ“
                    const i = document.createElement('i');
                    // å°‡ kebab-case è½‰æ›ç‚º Lucide å±¬æ€§æ ¼å¼
                    const attrName = name.replace(/([a-z0-9])([A-Z])/g, '$1-$2').toLowerCase();
                    i.setAttribute('data-lucide', attrName);
                    i.style.width = `${size}px`;
                    i.style.height = `${size}px`;
                    iconRef.current.appendChild(i);
                    
                    // èª¿ç”¨ Lucide çš„æ¸²æŸ“æ–¹æ³•
                    window.lucide.createIcons({
                        attrs: {
                            'stroke-width': 2,
                            width: size,
                            height: size
                        },
                        nameAttr: 'data-lucide',
                        icons: window.lucide.icons
                    });
                }
            }, [name, size]);

            return <span ref={iconRef} className={`inline-flex items-center justify-center leading-none ${className}`} style={{ width: size, height: size }}></span>;
        };

        const App = () => {
            const [numbers, setNumbers] = useState([]);
            const [algorithm, setAlgorithm] = useState('bubble'); 
            const [step, setStep] = useState(0);
            const [subStep, setSubStep] = useState(0); 
            const [highlightIndices, setHighlightIndices] = useState([]);
            const [sortedIndices, setSortedIndices] = useState([]);
            const [message, setMessage] = useState('');
            const [errorMsg, setErrorMsg] = useState('');
            const [isComplete, setIsComplete] = useState(false);
            const [tempValue, setTempValue] = useState(null); 
            const [shakingIdx, setShakingIdx] = useState(null);
            
            const [isChallengeMode, setIsChallengeMode] = useState(false);
            const [startTime, setStartTime] = useState(null);
            const [elapsedTime, setElapsedTime] = useState(0);
            const [bestScores, setBestScores] = useState({ bubble: null, selection: null, insertion: null });
            const timerRef = useRef(null);

            const initGame = () => {
                const size = 6;
                const min = 5;
                const max = 50;
                const stepRange = Math.floor((max - min) / size);
                let baseNums = Array.from({ length: size }, (_, i) => min + (i * stepRange) + Math.floor(Math.random() * stepRange));
                for (let i = baseNums.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [baseNums[i], baseNums[j]] = [baseNums[j], baseNums[i]];
                }
                const newNums = baseNums;
                setNumbers(newNums);
                setStep(0);
                setSubStep(0);
                setHighlightIndices([]);
                setSortedIndices([]);
                setIsComplete(false);
                setTempValue(null);
                setElapsedTime(0);
                setStartTime(null);
                setErrorMsg('');
                if (timerRef.current) clearInterval(timerRef.current);
                updateInstruction(algorithm, 0, 0, newNums, [], null, true);
            };

            useEffect(() => { initGame(); }, [algorithm]);

            const startTimer = () => {
                if (!startTime && isChallengeMode) {
                    const now = Date.now();
                    setStartTime(now);
                    timerRef.current = setInterval(() => {
                        setElapsedTime(Math.floor((Date.now() - now) / 1000));
                    }, 1000);
                }
            };

            const triggerError = (idx, msg) => {
                setShakingIdx(idx);
                setErrorMsg(msg);
                setTimeout(() => { setShakingIdx(null); setErrorMsg(''); }, 1000);
            };

            const updateInstruction = (algo, s, ss, currentNums, currentSorted, temp = null, isFirstStep = false) => {
                if (isChallengeMode && !isFirstStep) {
                    setMessage("ã€ç«¶è³½ä¸­ã€‘ï¼šè«‹æ†‘è¨˜æ†¶èˆ‡é‚è¼¯å®Œæˆå‰©é¤˜æ’åºæ­¥é©Ÿï¼");
                    setHighlightIndices([]);
                    return;
                }
                if (algo === 'bubble') {
                    const limit = currentNums.length - 1 - currentSorted.length;
                    const j = s % limit;
                    setMessage(`ã€æç¤ºã€‘ï¼šæ¯”è¼ƒä½ç½® ${j} èˆ‡ ${j + 1}ã€‚è«‹é»æ“Šã€Œè¼ƒå¤§ã€çš„æ•¸å­—é€²è¡Œæ’åºã€‚`);
                    setHighlightIndices([j, j + 1]);
                } else if (algo === 'selection') {
                    const i = currentSorted.length;
                    if (ss === 0) {
                        setMessage(`ã€æç¤ºã€‘ï¼šè«‹å…ˆé»æ“Šä½ç½® ${i} çš„æ–¹å¡Šï¼Œæº–å‚™é€²è¡Œäº¤æ›ã€‚`);
                        setHighlightIndices([i]);
                    } else {
                        const remainingNums = currentNums.slice(i);
                        const minVal = Math.min(...remainingNums);
                        const minIdx = currentNums.indexOf(minVal, i);
                        setMessage(`ã€å°‹æ‰¾ã€‘ï¼šè«‹é»æ“Šå¾Œé¢æ•¸åˆ—ä¸­ã€Œæœ€å°ã€çš„æ•¸å­— (${minVal}) ä¾†èˆ‡ä½ç½® ${i} äº¤æ›ã€‚`);
                        setHighlightIndices([i, minIdx]);
                    }
                } else if (algo === 'insertion') {
                    const i = currentSorted.length === 0 ? 1 : currentSorted.length;
                    if (temp === null) {
                        setMessage(`ã€æå–ã€‘ï¼šè«‹é»æ“Šä½ç½® ${i} çš„æ•¸å­— (${currentNums[i]}) å°‡å…¶ã€Œæ‹”å‡ºã€æš«å­˜ã€‚`);
                        setHighlightIndices([i]);
                    } else {
                        setMessage(`ã€ç§»å‹•ã€‘ï¼šè‹¥å·¦å´æ•¸å­—æ¯” ${temp} å¤§ï¼Œé»æ“Šå®ƒå‘å³ç§»ï¼›è‹¥ä½ç½®æ­£ç¢ºï¼Œé»æ“Šç©ºä½æ”¾å›ã€‚`);
                    }
                }
            };

            const handleBlockClick = (index) => {
                if (isComplete || errorMsg) return;
                startTimer();
                if (algorithm === 'bubble') handleBubble(index);
                else if (algorithm === 'selection') handleSelection(index);
                else if (algorithm === 'insertion') handleInsertion(index);
            };

            const handleBubble = (index) => {
                const limit = numbers.length - 1 - sortedIndices.length;
                const j = step % limit;
                if (index !== j && index !== j + 1) return;
                const leftVal = numbers[j];
                const rightVal = numbers[j + 1];
                const maxVal = Math.max(leftVal, rightVal);
                if (numbers[index] !== maxVal) {
                    triggerError(index, "é¸éŒ¯å›‰ï¼æ°£æ³¡æ’åºè¦é—œæ³¨è¼ƒå¤§çš„æ•¸å­—ã€‚");
                    return;
                }
                const newNums = [...numbers];
                if (leftVal > rightVal) {
                    [newNums[j], newNums[j + 1]] = [newNums[j + 1], newNums[j]];
                    setNumbers(newNums);
                }
                const nextStep = step + 1;
                if (nextStep >= limit) {
                    const newSorted = [...sortedIndices, numbers.length - 1 - sortedIndices.length];
                    setSortedIndices(newSorted);
                    setStep(0);
                    if (newSorted.length === numbers.length - 1) {
                        setIsComplete(true);
                        setSortedIndices([0, 1, 2, 3, 4, 5]);
                        setMessage(`æ­å–œå®Œæˆï¼ç¸½è€—æ™‚ï¼š${elapsedTime} ç§’ã€‚`);
                    } else {
                        updateInstruction('bubble', 0, 0, newNums, newSorted, null, false);
                    }
                } else {
                    setStep(nextStep);
                    updateInstruction('bubble', nextStep, 0, newNums, sortedIndices, null, false);
                }
            };

            const handleSelection = (index) => {
                const i = sortedIndices.length;
                const remaining = numbers.slice(i);
                const minVal = Math.min(...remaining);
                const minIdx = numbers.indexOf(minVal, i);
                if (subStep === 0) {
                    if (index === i) {
                        setSubStep(1);
                        updateInstruction('selection', 0, 1, numbers, sortedIndices, null, false);
                    } else { triggerError(index, `è«‹å…ˆé»æ“Šç›®æ¨™ä½ç½® ${i}ã€‚`); }
                } else {
                    if (index === minIdx) {
                        const newNums = [...numbers];
                        [newNums[i], newNums[minIdx]] = [newNums[minIdx], newNums[i]];
                        setNumbers(newNums);
                        const newSorted = [...sortedIndices, i];
                        setSortedIndices(newSorted);
                        setSubStep(0);
                        if (newSorted.length >= numbers.length - 1) {
                            setIsComplete(true);
                            setSortedIndices([0, 1, 2, 3, 4, 5]);
                            setMessage(`æ­å–œå®Œæˆï¼ç¸½è€—æ™‚ï¼š${elapsedTime} ç§’ã€‚`);
                        } else { updateInstruction('selection', 0, 0, newNums, newSorted, null, false); }
                    } else { triggerError(index, "é€™ä¸æ˜¯å‰©ä¸‹çš„æ•¸å­—ä¸­æœ€å°çš„å–”ï¼"); }
                }
            };

            const handleInsertion = (index) => {
                const i = sortedIndices.length === 0 ? 1 : sortedIndices.length;
                if (tempValue === null) {
                    if (index === i) {
                        const val = numbers[i];
                        setTempValue(val);
                        const newNums = [...numbers];
                        newNums[i] = null;
                        setNumbers(newNums);
                        updateInstruction('insertion', 0, 1, newNums, sortedIndices, val, false);
                    } else { triggerError(index, `è«‹å…ˆæ‹”å‡ºç¬¬ ${i} å€‹æ•¸å­—ã€‚`); }
                } else {
                    const nullIdx = numbers.indexOf(null);
                    if (index === nullIdx - 1) {
                        if (numbers[index] > tempValue) {
                            const newNums = [...numbers];
                            newNums[nullIdx] = newNums[index];
                            newNums[index] = null;
                            setNumbers(newNums);
                            updateInstruction('insertion', 0, 1, newNums, sortedIndices, tempValue, false);
                        } else { triggerError(index, "ä¸éœ€å³ç§»ã€‚"); }
                    } else if (index === nullIdx) {
                        if (nullIdx === 0 || numbers[nullIdx - 1] <= tempValue) {
                            const newNums = [...numbers];
                            newNums[nullIdx] = tempValue;
                            setNumbers(newNums);
                            setTempValue(null);
                            const nextSortedLen = i + 1;
                            const newSorted = Array.from({ length: nextSortedLen }, (_, k) => k);
                            setSortedIndices(newSorted);
                            if (nextSortedLen === numbers.length) {
                                setIsComplete(true);
                                setMessage(`æ­å–œå®Œæˆï¼ç¸½è€—æ™‚ï¼š${elapsedTime} ç§’ã€‚`);
                            } else { updateInstruction('insertion', 0, 0, newNums, newSorted, null, false); }
                        } else { triggerError(index, "å·¦é‚Šé‚„æœ‰å¤§æ•¸ï¼"); }
                    }
                }
            };

            useEffect(() => {
                if (isComplete && timerRef.current) {
                    clearInterval(timerRef.current);
                    if (isChallengeMode) {
                        setBestScores(prev => ({
                            ...prev,
                            [algorithm]: prev[algorithm] === null ? elapsedTime : Math.min(prev[algorithm], elapsedTime)
                        }));
                    }
                }
            }, [isComplete]);

            return (
                <div className={`min-h-screen p-4 md:p-8 transition-all duration-500 ${isChallengeMode ? 'bg-slate-900 text-slate-100' : 'bg-slate-50 text-slate-800'}`}>
                    <div className="max-w-4xl mx-auto">
                        <header className="text-center mb-6">
                            <div className="flex items-center justify-center gap-2 mb-2">
                                <h1 className={`text-3xl font-bold ${isChallengeMode ? 'text-amber-400' : 'text-indigo-700'}`}>æ’åºç«¶è³½å¯¦é©—å®¤</h1>
                                {isChallengeMode && <Icon name="Swords" className="text-amber-400 animate-pulse" />}
                            </div>
                            <p className="opacity-70">æ­£ç¢ºæ“ä½œæ¼”ç®—æ³•ï¼ŒæŒ‘æˆ°æœ€å¿«é€Ÿåº¦ï¼</p>
                        </header>

                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6 text-center">
                            <div className={`p-3 rounded-xl border ${isChallengeMode ? 'bg-slate-800 border-amber-500/30' : 'bg-white shadow-sm'}`}>
                                <div className="text-xs text-slate-400 uppercase">æ™‚é–“</div>
                                <div className="text-xl font-mono font-bold text-amber-500">{elapsedTime}s</div>
                            </div>
                            <div className={`p-3 rounded-xl border ${isChallengeMode ? 'bg-slate-800 border-amber-500/30' : 'bg-white shadow-sm'}`}>
                                <div className="text-xs text-slate-400 uppercase">æœ€ä½³ç´€éŒ„</div>
                                <div className="text-xl font-mono font-bold text-indigo-400">{bestScores[algorithm] || '--'}s</div>
                            </div>
                            <button onClick={() => { setIsChallengeMode(!isChallengeMode); initGame(); }} className={`col-span-2 py-3 rounded-xl font-bold transition-all shadow-lg ${isChallengeMode ? 'bg-amber-500 text-slate-900' : 'bg-slate-800 text-white'}`}>
                                {isChallengeMode ? "åˆ‡æ›è‡³ å­¸ç¿’æ¨¡å¼ (å…¨æç¤º)" : "ğŸ”¥ é–‹å•Ÿ ç«¶è³½æ¨¡å¼ (é¦–æ­¥æç¤º)"}
                            </button>
                        </div>

                        <div className="flex justify-center gap-2 mb-8">
                            {['bubble', 'selection', 'insertion'].map((a) => (
                                <button key={a} onClick={() => setAlgorithm(a)} className={`px-4 py-2 rounded-lg text-sm font-bold transition-all ${algorithm === a ? 'bg-indigo-600 text-white scale-105 shadow-md' : 'bg-slate-200 text-slate-600'}`}>
                                    {a === 'bubble' ? 'æ°£æ³¡' : a === 'selection' ? 'é¸æ“‡' : 'æ’å…¥'}æ’åº
                                </button>
                            ))}
                        </div>

                        <div className={`rounded-2xl shadow-2xl p-6 md:p-10 mb-6 border-t-8 transition-all ${isChallengeMode ? 'bg-slate-800 border-amber-500' : 'bg-white border-indigo-500'}`}>
                            <div className={`flex items-center gap-3 p-4 mb-8 rounded-lg transition-all ${errorMsg ? 'bg-red-100 border-red-500 text-red-700 animate-bounce' : isChallengeMode ? 'bg-slate-700 text-slate-200' : 'bg-indigo-50 text-indigo-900'}`}>
                                <Icon name={errorMsg ? "AlertCircle" : "Info"} size={20} />
                                <p className="font-bold ml-2">{errorMsg || message}</p>
                            </div>

                            <div className="flex flex-col items-center gap-12 justify-center h-64">
                                <div className="flex gap-4 items-end">
                                    {numbers.map((num, idx) => (
                                        <div key={idx} className={`flex flex-col items-center gap-3 transition-transform ${shakingIdx === idx ? 'animate-shake' : ''}`}>
                                            <div className={`w-12 md:w-16 rounded-t-lg transition-all duration-300 ${num === null ? 'h-0 opacity-0' : 'opacity-100'} ${highlightIndices.includes(idx) ? 'bg-yellow-400 shadow-[0_0_15px_rgba(250,204,21,0.5)]' : sortedIndices.includes(idx) ? 'bg-green-400' : 'bg-slate-400'}`} style={{ height: num ? `${num * 2.5}px` : '0px' }} />
                                            <button onClick={() => handleBlockClick(idx)} className={`w-12 h-12 md:w-16 md:h-16 flex items-center justify-center text-xl font-bold rounded-xl border-4 transition-all ${num === null ? 'border-dashed border-slate-600 bg-transparent' : highlightIndices.includes(idx) ? 'bg-yellow-400 border-yellow-200 text-yellow-900 scale-110' : sortedIndices.includes(idx) ? 'bg-green-500 border-green-200 text-white' : 'bg-slate-100 border-slate-200 text-slate-700'}`}>
                                                {num}
                                            </button>
                                            <span className="text-[10px] font-mono opacity-50">POS: {idx}</span>
                                        </div>
                                    ))}
                                </div>

                                {algorithm === 'insertion' && (
                                    <div className="flex flex-col items-center gap-2">
                                        <div className="text-xs font-bold uppercase tracking-widest opacity-40">æš«å­˜ä½ç½® (Hand)</div>
                                        <div className={`w-16 h-16 flex items-center justify-center text-2xl font-bold rounded-2xl border-4 transition-all ${tempValue ? 'bg-orange-500 border-orange-200 text-white scale-125 shadow-2xl animate-pulse' : 'bg-slate-700/20 border-dashed border-slate-500 text-transparent'}`}>
                                            {tempValue}
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        <button onClick={initGame} className="w-full py-4 bg-slate-200 hover:bg-slate-300 text-slate-700 font-bold rounded-xl transition-colors flex items-center justify-center gap-2">
                            <Icon name="RefreshCw" size={20} /> é‡ç½®é¡Œç›®
                        </button>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>